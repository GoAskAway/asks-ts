#!/usr/bin/env node

'use strict';

const fs = require('fs');
const path = require('path');
const protobuf = require('protobufjs');

const SCAFFOLD_MARKER = 'ASKS_TS_SCAFFOLD';

function parseArgs(argv) {
  const args = {};
  for (let i = 2; i < argv.length; i += 1) {
    const arg = argv[i];
    if (!arg.startsWith('--')) continue;
    const key = arg.slice(2);
    const next = argv[i + 1];
    if (next && !next.startsWith('--')) {
      args[key] = next;
      i += 1;
    } else {
      args[key] = true;
    }
  }
  return args;
}

function usage() {
  const message = [
    'Usage: generate-ask-service --proto <ask.proto> [--out-dir <src>] [--service <ServiceName>] [--force]',
    '',
    'Example:',
    '  node scripts/generate-ask-service.cjs --proto askaway-proto/ask.proto --out-dir src --service AskService',
  ].join('\n');
  console.error(message);
}

function ensureDir(dirPath) {
  fs.mkdirSync(dirPath, { recursive: true });
}

function pascalCase(value) {
  return String(value)
    .split(/[^a-zA-Z0-9]+/g)
    .filter(Boolean)
    .map((part) => part.charAt(0).toUpperCase() + part.slice(1))
    .join('');
}

function toSnakeCase(name) {
  return String(name)
    .replace(/([a-z0-9])([A-Z])/g, '$1_$2')
    .replace(/[^a-zA-Z0-9]+/g, '_')
    .toLowerCase();
}

function toLowerCamel(name) {
  const value = String(name);
  if (value.length === 0) return value;
  return value.charAt(0).toLowerCase() + value.slice(1);
}

function getPackageName(obj) {
  let node = obj.parent;
  const parts = [];
  while (node && !(node instanceof protobuf.Root)) {
    if (node instanceof protobuf.Namespace && !(node instanceof protobuf.Type)) {
      if (node.name) parts.unshift(node.name);
    }
    node = node.parent;
  }
  return parts.join('.');
}

function getTypePath(type) {
  const names = [type.name];
  let node = type.parent;
  while (node && node instanceof protobuf.Type) {
    names.unshift(node.name);
    node = node.parent;
  }
  return names.join('_');
}

function buildTypeNameMap(packages) {
  const map = new Map();
  for (const [pkg, data] of packages.entries()) {
    const prefix = pkg ? `${pascalCase(pkg)}_` : '';
    for (const type of data.types) {
      const name = `${prefix}${getTypePath(type)}`;
      map.set(type.fullName, name);
    }
  }
  return map;
}

function collectPackages(root) {
  const packages = new Map();

  function ensure(pkg) {
    if (!packages.has(pkg)) packages.set(pkg, { types: [], services: [] });
    return packages.get(pkg);
  }

  function visit(namespace) {
    if (!namespace.nestedArray) return;
    for (const nested of namespace.nestedArray) {
      if (nested instanceof protobuf.Type) {
        const pkg = getPackageName(nested);
        ensure(pkg).types.push(nested);
      }
      if (nested instanceof protobuf.Service) {
        const pkg = getPackageName(nested);
        ensure(pkg).services.push(nested);
      }
      if (nested.nestedArray) visit(nested);
    }
  }

  visit(root);
  return packages;
}

function renderRuntime(serviceInfo, typeNameMap) {
  const { pkg, service } = serviceInfo;
  const fileBase = pkg ? pkg.replace(/\./g, '-') : 'root';
  const serviceName = service.name;
  const methodNames = service.methodsArray.map((method) => method.name);
  const hasDuplicateMethod = methodNames.length !== new Set(methodNames).size;

  const lines = [];
  lines.push('// DO NOT EDIT.');
  lines.push('// Generated by asks-ts codegen.');
  lines.push('');
  lines.push("import type { ContextBridge, RpcEnvelopeBridge, Workload } from '@actor-rtc/actr';");
  lines.push('');

  const routeImports = [];
  for (const method of service.methodsArray) {
    const constBase = hasDuplicateMethod ? `${serviceName}_${method.name}` : method.name;
    const constName = `${constBase.replace(/[^a-zA-Z0-9]/g, '_').toUpperCase()}_ROUTE_KEY`;
    routeImports.push(constName);
  }
  lines.push(`import { ${routeImports.join(', ')} } from './generated/${fileBase}.client.js';`);

  const typeImports = new Set();
  for (const method of service.methodsArray) {
    if (method.resolvedRequestType) typeImports.add(typeNameMap.get(method.resolvedRequestType.fullName));
    if (method.resolvedResponseType) typeImports.add(typeNameMap.get(method.resolvedResponseType.fullName));
  }
  lines.push(`import { ${Array.from(typeImports).filter(Boolean).sort().join(', ')} } from './generated/${fileBase}.pb.js';`);
  lines.push('');

  lines.push(`export interface ${serviceName}Handlers {`);
  for (const method of service.methodsArray) {
    const reqType = typeNameMap.get(method.resolvedRequestType.fullName);
    const resType = typeNameMap.get(method.resolvedResponseType.fullName);
    const methodName = toLowerCamel(method.name);
    lines.push(`  ${methodName}: (request: ${reqType}, ctx: ContextBridge) => Promise<${resType}>;`);
  }
  lines.push('}');
  lines.push('');

  lines.push(`export class ${serviceName}Workload implements Workload {`);
  lines.push(`  constructor(private readonly handlers: ${serviceName}Handlers) {}`);
  lines.push('');
  lines.push('  async onStart(_ctx: ContextBridge): Promise<void> {');
  lines.push(`    console.log('${serviceName} workload started');`);
  lines.push('  }');
  lines.push('');
  lines.push('  async onStop(_ctx: ContextBridge): Promise<void> {');
  lines.push(`    console.log('${serviceName} workload stopped');`);
  lines.push('  }');
  lines.push('');
  lines.push('  async dispatch(ctx: ContextBridge, envelope: RpcEnvelopeBridge): Promise<Buffer> {');

  for (const method of service.methodsArray) {
    const constBase = hasDuplicateMethod ? `${serviceName}_${method.name}` : method.name;
    const constName = `${constBase.replace(/[^a-zA-Z0-9]/g, '_').toUpperCase()}_ROUTE_KEY`;
    const reqType = typeNameMap.get(method.resolvedRequestType.fullName);
    const resType = typeNameMap.get(method.resolvedResponseType.fullName);
    const methodName = toLowerCamel(method.name);

    lines.push(`    if (envelope.routeKey === ${constName}) {`);
    lines.push(`      const request = ${reqType}.decode(envelope.payload);`);
    lines.push(`      const response = await this.handlers.${methodName}(request, ctx);`);
    lines.push(`      return ${resType}.encode(response);`);
    lines.push('    }');
    lines.push('');
  }

  lines.push('    throw new Error(`Unknown route: ${envelope.routeKey}`);');
  lines.push('  }');
  lines.push('}');
  lines.push('');
  lines.push(`export function create${serviceName}Workload(handlers: ${serviceName}Handlers): ${serviceName}Workload {`);
  lines.push(`  return new ${serviceName}Workload(handlers);`);
  lines.push('}');

  return lines.join('\n');
}

function renderScaffold(serviceInfo, typeNameMap) {
  const { pkg, service } = serviceInfo;
  const fileBase = pkg ? pkg.replace(/\./g, '-') : 'root';
  const serviceName = service.name;

  const typeImports = new Set();
  for (const method of service.methodsArray) {
    if (method.resolvedRequestType) typeImports.add(typeNameMap.get(method.resolvedRequestType.fullName));
    if (method.resolvedResponseType) typeImports.add(typeNameMap.get(method.resolvedResponseType.fullName));
  }

  const lines = [];
  lines.push(`// ${SCAFFOLD_MARKER}`);
  lines.push('// Generated scaffold for user code.');
  lines.push('// Fill in the TODOs with your business logic.');
  lines.push('');
  lines.push("import type { ContextBridge } from '@actor-rtc/actr';");
  lines.push('');
  lines.push(`import type { ${Array.from(typeImports).filter(Boolean).sort().join(', ')} } from './generated/${fileBase}.pb.js';`);
  lines.push(`import type { ${serviceName}Handlers } from './${toSnakeCase(serviceName)}_runtime.js';`);
  lines.push('');
  lines.push(`export class ${serviceName}Handler implements ${serviceName}Handlers {`);

  const todoHints = {
    prompt: [
      'Validate required fields (questionId, sessionId, text/voiceStreamId).',
      'Perform your core processing (LLM, retrieval, workflow, etc.).',
      'Populate statusCode and errorMessage on failure.',
      'Set streamId if you produce a streaming response.',
    ],
    attach: [
      'Validate attachment metadata (id, filename, type).',
      'Persist data and return status/error.',
    ],
    unregisterDataStream: [
      'Validate streamId and release any streaming resources.',
    ],
  };

  for (const method of service.methodsArray) {
    const reqType = typeNameMap.get(method.resolvedRequestType.fullName);
    const resType = typeNameMap.get(method.resolvedResponseType.fullName);
    const methodName = toLowerCamel(method.name);

    lines.push(`  async ${methodName}(request: ${reqType}, _ctx: ContextBridge): Promise<${resType}> {`);
    lines.push(`    // TODO: Implement ${methodName} business logic.`);
    const hints = todoHints[methodName] || ['Validate input and return a response.'];
    for (const hint of hints) {
      lines.push(`    // TODO: ${hint}`);
    }
    lines.push('    void request;');
    lines.push(`    throw new Error('TODO: implement ${methodName}');`);
    lines.push('  }');
    lines.push('');
  }

  lines.push('}');
  return lines.join('\n');
}

function shouldOverwriteScaffold(filePath, force) {
  if (force) return true;
  if (!fs.existsSync(filePath)) return true;
  const content = fs.readFileSync(filePath, 'utf8');
  return content.includes(SCAFFOLD_MARKER);
}

async function main() {
  const args = parseArgs(process.argv);
  if (!args.proto) {
    usage();
    process.exit(1);
  }

  const protoPath = path.resolve(args.proto);
  const outDir = path.resolve(args['out-dir'] || args.outDir || 'src');
  const serviceName = args.service || null;
  const force = Boolean(args.force);

  const root = await protobuf.load([protoPath]);
  root.resolveAll();

  const packages = collectPackages(root);
  const typeNameMap = buildTypeNameMap(packages);

  const services = [];
  for (const [pkg, data] of packages.entries()) {
    for (const service of data.services) {
      services.push({ pkg, service });
    }
  }

  if (services.length === 0) {
    throw new Error('No service definitions found in proto.');
  }

  let selected = services[0];
  if (serviceName) {
    const match = services.find((entry) => entry.service.name === serviceName);
    if (!match) {
      throw new Error(`Service ${serviceName} not found in proto.`);
    }
    selected = match;
  } else if (services.length > 1) {
    throw new Error('Multiple services found. Please specify --service.');
  }

  ensureDir(outDir);

  const serviceFileBase = toSnakeCase(selected.service.name);
  const runtimePath = path.join(outDir, `${serviceFileBase}_runtime.ts`);
  const scaffoldPath = path.join(outDir, `${serviceFileBase}.ts`);

  const runtimeContent = renderRuntime(selected, typeNameMap);
  fs.writeFileSync(runtimePath, runtimeContent);

  if (shouldOverwriteScaffold(scaffoldPath, force)) {
    const scaffoldContent = renderScaffold(selected, typeNameMap);
    fs.writeFileSync(scaffoldPath, scaffoldContent);
  }
}

main().catch((error) => {
  console.error(error);
  process.exit(1);
});
